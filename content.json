[{"title":"Runtime浅谈(一)","date":"2017-07-04T02:39:05.000Z","path":"2017/07/04/Runtime浅谈-一/","text":"运行时机制C语言是一种静态语言，而OC是一个依托于C的语言。为了保持了C编译时的功能（如类型检查），并且增加灵活性，OC在C的基础上，借鉴了smalltalk的消息传递机制为其添加了运行时机制，这也就是runtime机制。换种方式来说，runtime机制是一个由C和汇编编写的Library，而这个Library给C增加了面向对象的特性，从而形成了OC语言。 基于runtime，OC中对象的类型和对象所执行的方法都是在运行时阶段进行查找并确认的，这种机制被称为动态绑定。 OC中的代码无时无刻不在是运用Runtime,那么Runtime是怎么帮我们工作的呢？它是通过objc_msgSend来进行工作的。 objc_msgSendOC中，对象调用方法，也叫给对象发送消息，实际上是使用了动态绑定机制。在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得Objective-C成为一门真正的动态语言。 通常我们在OC中这样发送消息：1id returnValue = [someObject messageName:parameter]; someObject是消息的接受者,messageName是一个选择器，parameter则为参数。选择器+参数 就是我们所称为的消息。在底层，编译器将我们的消息转换文标准的C函数形式，如下：1void objc_msgSend(id self,SEL cmd,…) self 为消息接收者，cmd为选择器，省略号为参数，表示可变长度参数。因此，以上的消息转换为标准的C函数后如下：1id returnValue = objc_msgSend(someObject,@selector(messageName),paramter) 之所以objc_msgSend方法总能找到正确的函数去执行，原因如下：其实每个类中都有一张方法列表去存储这个类中有的方法，当发出objc_msgSend方法时候，就会顺着列表去找这个方法是否存在，如果不存在，则向该类的父类继续查找，直到找到位置。如果始终没有找到方法，那么就会进入到消息转发机制（后续知识，以后章节会介绍） 。OC runtime还有一个机制在于方法缓存，每调用完这个方法后，一个方法映射就会被缓存起来，如果之后调用相同的方法，那么就能直接从映射表里确定方法的位置，而不用每次都需要查找，这样执行速度会快一点。 objc_msgSend_stret如果待发送的消息要返回结构体，那么可交由此函数处理。只有当CPU的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于CPU寄存器中（比如说返回的结构体太大了），那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。 objc_msgSend_fpret 如果消息返回的是浮点数，那么可交由此函数处理。在某些架构的CPU中调用函数时，需要对“浮点数寄存器”（floating-point register）做特殊处理，也就是说，通常所用的objc_msgSend在这种情况下并不合适。这个函数是为了处理x86等架构CPU中某些令人稍觉惊讶的奇怪状况。 objc_msgSendSuper如果要给超类发消息，例如[super message:parameter]，那么就交由此函数处理。也有另外两个与objc_msgSend_stret和objc_msgSend_fpret等效的函数，用于处理发给super的相应消息。 以上内容摘抄自网上翻译，因为英文原文这部分实在是不太好理解。我觉得可以简单的按照字面意思来进行选择，比如你希望函数返回体为结构体，那么就使用objc_msgSend_stret，否则有几率会崩溃。返回值为浮点数时也是相同道理。 上文说过，当找到相应的方法时，会跳转过去。之所以可以这样实现，是因为每一个Objective-C函数都可以看作是一个简单的C函数，原型如下：1&lt;return_type&gt; Class_selector(id self,SEL _cmd,...) 以上Class及selector的命名是为了方便理解。每个类中都有一张类似于字典的方法表，而selector就相当于查找方法的key，objc_msgSend函数就是通过查这张表来实现跳转的。之所以以上原型和objc_msgSend方法长的非常相像，是为了更好使用tail-call技术来时方法的跳转更加优化。 如果某函数的最后一项操作是调用另外一个函数，那么就可以运用“tail-call”技术。此时编译器会生成调转至另一函数所需的指令码，而不会向调用堆栈中推入新的“栈帧”。tail-call使用的条件比较苛刻，除了要求函数的最后一项操作是调用另外一个函数外，，并且要求另外一个函数不是有返回值的函数类型。tail-call对objc_msgSend非常关键，如果不这么做的话，那么每次调用Objective-C方法之前，都需要为调用objc_msgSend函数准备“栈帧”，若是不优化，还会过早地发生“栈溢出”（stack overflow）现象。 在写OC中，我们其实并不需要了解那么多底层的东西，但是我们需要知道调用一个方法之后，OC底层都发生了什么。 123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;#import &quot;StudentClass.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; StudentClass *stu = [StudentClass alloc]; stu = [stu init]; [stu setUserName:@&quot;小强5号&quot;]; NSLog(@&quot;%@&quot;,stu.userName); //NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 上述代码转义后通过objc_msgsend表现的代码,代码太多只显示转义所需要的内容 123456789101112131415int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; StudentClass *stu = ((StudentClass *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;StudentClass&quot;), sel_registerName(&quot;alloc&quot;)); stu = ((StudentClass *(*)(id, SEL))(void *)objc_msgSend)((id)stu, sel_registerName(&quot;init&quot;)); ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)stu, sel_registerName(&quot;setUserName:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_5z_1pxqzfcn77s2n7z4gmr63sdr0000gn_T_main_9f5caf_mi_0); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_5z_1pxqzfcn77s2n7z4gmr63sdr0000gn_T_main_9f5caf_mi_1,((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)stu, sel_registerName(&quot;userName&quot;))); &#125; return 0;&#125; 在终端输入你要转义的文件就可以了 clang -rewrite-objc main.m 简易的可以看成 12345Student *stu = objc_msgSend(objc_getClass(&quot;StudentClass&quot;),sel_registerName(&quot;alloc&quot;) );stu = objc_msgSend(stu, sel_registerName(&quot;init&quot;));objc_msgSend(stu,sel_registerName(&quot;init&quot;),@&quot;小强5号&quot;); objc_object、objc_class在runtime的源码中，在objc.h和runtime.h中分别可以找到objc_object和obc_class的代码实现 objc_object 1234typedef struct objc_class *Class;struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; 通过源码可以看出obc_object在runtime的时候是一个objc_class的结构体，结构体里又只向一个objc_class的指针isa。动态类型id其实就是一个objc_object。 objc_class 1234567891011121314struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; //父类 const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE;//版本号 long info OBJC2_UNAVAILABLE;//这个类的信息 long instance_size OBJC2_UNAVAILABLE;//类的大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE;//成员变量 struct objc_method_list **methodLists OBJC2_UNAVAILABLE;//实例的方法 struct objc_cache *cache OBJC2_UNAVAILABLE;//缓存 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; //协议#endif&#125; OBJC2_UNAVAILABLE; 相比objc_object，objc_class的结构体里面的东西比较多了。仔细观察objc_class中也有一个isa指针，然而这个指针并不是指向自己而是指向mateclass(元类) 元类是类对象的类，类对象是元类的实例。基于这种设计模式，不难发现：1.我们以前调用 “+” 开头的类方法实际是在调用元类的对象方法2.由于每个类有且只有一个，所以每个类对象都是其对应元类的单例那么,元类是对象吗？答案是肯定的，元类是对象。如果元类也是对象，元类的类又是什么？ 下图解释: 123456其实到这就明白了:1 . objc_object中的isa 指的是对象的类;2 . objc_class中的isa只的是类的元类;3 . superClass是一层层集成的,到最后NSObject的superClass是nil.而NSObject的isa指向根元类,这个跟元类的isa指向它自己,而它的superClass是NSObject,也就是最后形成一个环,这个环让我想起了先有鸡还是先有蛋的问题.4 . mateClass也是相互继承的.5 . 这个逻辑就想着objc_class的struct,里面有个isa属性,还有个super_class属性,他俩都是指针,其实在objc_class的定义中也能看出来,每一个objc_class都有isa,但是不一定会有super_class,近三天每天想一次. objc_method、SEL、IMPobjc_method 12345struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; OC中每一个方法的实例都是如上结构体，里面主要的两个关键字段method_name和method_imp共同为方法的查找和调用的标识 SEL从SEL类型的成员为method_name可以知道，SEL大概代表一个方法的名字，可以通过以下方式检验。12345678910111213141516171819202122#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;@interface A : NSObject@property (nonatomic, assign) NSInteger a;- (void)b;+ (void)c;@end@implementation A- (void)b &#123;&#125;+ (void)c &#123; NSLog(@&quot;%s&quot;, @selector(b));&#125;@endint main(int argc, char * argv[]) &#123; [A c];&#125;// 输出2017-07-04 15:23:03.850 block[57622:533311] b IMPSEL的作用很容易理解，即想找到想要的objc_method结构体，需要通过SEL来遍历，那么，IMP是什么呢？一般来说，通过SEL找到想要的objc_method，下一步就是调用方法的实现了，objc_method结构体中唯一有可能和方法实现相关的就是IMP了。所以，IMP是一个函数指针，指向objc_method对应方法的实现部分。 objc_method中的method_types指的是方法的返回值和参数。以返回值开始，依次把参数拼在后面，比如”i@”，即为返回值为int类型，参数为一个对象，参照对照表 12345678910111213141516171819202122232425262728// 考虑到只用文字描述有点空洞，这里通过class_addMethod方法的使用做个样例//先看下class_addMethod定义，几个参数容易理解。cls为需要增加方法的类，后三个参数对应objc_method结构体中的几个成员。OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);// OC代码#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;@interface A : NSObject@property (nonatomic, assign) NSInteger a;- (void)b;@end@implementation A- (void)b &#123;&#125;@endint c(NSString *str) &#123; NSLog(@&quot;c&quot;); return 0;&#125;int main(int argc, char * argv[]) &#123; class_addMethod([A class], @selector(c:), (IMP)c, &quot;i@&quot;); A *aObject = [[A alloc] init]; [aObject performSelector:@selector(c:)];&#125;// 输出，可见完成了方法c的调用。2017-07-04 15:51:17.931 block[60624:567679] c objc_msgSend工作原理和实例方法调用1.objc_msgSend工作原理 123456789101112131415161718192021222324252627282930313233// 首先看一下objc_msgSend的方法实现的伪代码id objc_msgSend(id self, SEL op, ...) &#123; if (!self) return nil; // 关键代码（a） IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op); imp(self, op, ...); // 调用这个函数，伪代码...&#125;// 查找IMPIMP class_getMethodImplementation(Class cls, SEL sel) &#123; if (!cls || !sel) return nil; IMP imp = lookUpImpOrNil(cls, sel); if (!imp) &#123; ... // 执行动态绑定 &#125; IMP imp = lookUpImpOrNil(cls, sel); if (!imp) return _objc_msgForward; // 这个是用于消息转发的 return imp;&#125;// 遍历继承链，查找IMPIMP lookUpImpOrNil(Class cls, SEL sel) &#123; if (!cls-&gt;initialize()) &#123; _class_initialize(cls); &#125; Class curClass = cls; IMP imp = nil; do &#123; // 先查缓存,缓存没有时重建,仍旧没有则向父类查询 if (!curClass) break; if (!curClass-&gt;cache) fill_cache(cls, curClass); imp = cache_getImp(curClass, sel); if (imp) break; &#125; while (curClass = curClass-&gt;superclass); // 关键代码（b） return imp;&#125; 首先在Class中的缓存查找imp（没缓存则初始化缓存），如果没找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替imp。最后，执行这个imp。 2、实例方法调用 123456789101112131415161718192021222324// 实例方法调用，参照一objc_msgSend(aObject, sel_registerName(&quot;b&quot;));// 参照二中实例对象的结构typedef struct objc_class *Class;struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;// 顺便给出objc_class结构struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 结合关键代码（a）、关键代码（b）和上述结构，大概可以猜到实例方法的调用顺序：1、将一个objc_object结构体的isa指针（即其对应的objc_class结构体）和一个方法名SEL传入class_getMethodImplementation。2、在class_getMethodImplementation方法中，使用lookUpImpOrNil遍历继承链，若返回nil，则消息转发（消息转发下一章在讲）。3、在lookUpImpOrNil遍历继承链，即先在当前objc_class的cache中查找SEL，若没有，则在methodLists中查找，若存在，则将其放入该objc_class的cache中，然后返回IMP。若不存在，则通过super_class指针找到该class的父class，继续该步骤直到NSObject停止（NSObject的super_class指向nil）。4、执行得到的IMP。 类方法调用和元类（metaClass）1、类方法调用与实例方法调用区别类方法的调用和实例方法显然不用，后者是需要先创建一个实例，而这个实例在堆中有自己对应的objc_object结构体，是以这个结构体对应的其“私有”的objc_class结构体为基础进行消息传递的。那么，类方法呢？类方法不需要创建实例，每个类都有一个自己对应的现成的objc_class结构体。而类方法的调用也是以这个“公有”的objc_class结构体做操作的。 公有、私有指的是每个对象实例都有自己的objc_class（私有），实例方法的调用也是通过这个私有的objc_class，而每个类只有一个对应的objc_class（公有），任何地方调用类方法，都是通过这个公有的objc_class。 2、methodLists中的方法 1234567891011121314151617181920212223242526// OC代码#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;@interface A : NSObject@property (nonatomic, assign) NSInteger a;- (void)b;+ (void)d;@end@implementation A- (void)b &#123; NSLog(@&quot;b&quot;);&#125;+ (void)d &#123; NSLog(@&quot;d&quot;);&#125;@endint main(int argc, char * argv[]) &#123; // 在A对应的objc_class结构体的继承链中找到实例方法b IMP bIMP = class_getMethodImplementation([A class], @selector(b)); // 执行IMP bIMP();&#125;// 输出2017-07-04 18:21:39.810 block[74277:689120] b 类方法 123456789101112131415161718192021222324252627// OC代码#import &lt;UIKit/UIKit.h&gt;#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;@interface A : NSObject@property (nonatomic, assign) NSInteger a;- (void)b;+ (void)d;@end@implementation A- (void)b &#123; NSLog(@&quot;b&quot;);&#125;+ (void)d &#123; NSLog(@&quot;d&quot;);&#125;@endint main(int argc, char * argv[]) &#123; // 获取A类对应的metaClass Class aMeta = objc_getMetaClass(class_getName([A class])); // 在metaClass中找类方法d IMP dIMP = class_getMethodImplementation(aMeta, @selector(d)); dIMP();&#125;// 输出2017-07-04 18:27:19.290 block[74821:695164] d 可知，A的objc_class结构体有一个现成的metaClass，而它存有A类的类方法。这里大概可以想到A类的objc_class结构体里面的isa指针指向这个metaClass。 元类 1Class aMeta = objc_getMetaClass(class_getName([A class])); 可知，元类也是一个objc_class结构体。而相应的也有isa和super_class成员。super_class比较好理解，参照四中objc_msgSend实现，用于在继承链上方法的查找。而元类的isa均指向NSObject对应的元类，这里不多解释（NSObject对应元类的isa指向自己，其super_class指向NSObject，也不解释了）。 类方法调用流程 123456789101112131415161718// 类方法调用，参照一objc_msgSend(objc_getClass(&quot;A&quot;), sel_registerName(&quot;c&quot;));// 顺便给出objc_class结构struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 可知，objc_getClass(“A”)，即为获取A的class，结合四中objc_msgSend实现，将其isa指针指向的metaClass传入class_getMethodImplementation来进行查找，符合我们的预期。其后的步骤与实例方法相同。 以runtime示意图结尾","tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/xiaoqiang051512/xiaoqiang051512.github.io/tags/iOS/"}]},{"title":"iOS数据安全浅谈","date":"2017-06-28T08:13:56.000Z","path":"2017/06/28/iOS数据浅谈/","text":"前言 项目中数据的安全是非常重要的，2017年后苹果强制iOS开发者必须使用https，这在一定程度提高了项目的安全性，但仅仅靠https和post请求对数据安全的处理其实还是远远不够的。因此项目中我们还需要用到一些加密算法来保护数据。比如说在登录过程中我们会对密码进行MD5处理后再传输给服务器。因此趁有时间总结一下常见的数据加密算法。 数据安全简介 用户隐私数据不允许用明文在网络中传输 用户隐私数据不允许用明文存储在本地 app代码安全，常见的用代码混淆、加密、加壳 数据加密准则 用Base64编码防止明文传输（数据体积会增加1/3） 对普通请求、返回数据，生成MD5校验（MD5中加入动态密钥），进行数据完整性（简单防篡改，安全性较低，优点：快速）校验 对于重要的数据用RSA签名，防止篡改 对于标记敏感的数据，比如密码、身份证号等敏感信息客户端用RSA签名后进行传输，服务器通过AES/DES加密返回 用https+ssl 进行双向验证 防止中间人攻击 常用加密方式简介Https+sslhttps简介： HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版，在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。2017年开始苹果要求app必须使用https。 https与http的区别： https协议需要到ca申请证书，一般免费证书很少，需要交费 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全 代码实现 123456789101112131415161718 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];// 更改解析方式（请求网页源码应使用原始解析）manager.responseSerializer = [AFHTTPResponseSerializer serializer];// 设置对证书的处理方式// 允许自签名证书，必须的manager.securityPolicy.allowInvalidCertificates = YES;// 是否验证域名的CN字段（不是必须的，但是如果写YES，则必须导入证书）manager.securityPolicy.validatesDomainName = NO;[manager GET:@&quot;https://kyfw.12306.cn/otn&quot; parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSLog(@&quot;success---%@&quot;,[[NSString alloc]initWithData:responseObject encoding:NSUTF8StringEncoding]);&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; NSLog(@&quot;error---%@&quot;,error);&#125;]; Base64 Base64是基于64个可打印字符来便是二进制数据的表示方法。它通常用于储存、传输一些二进制数据编码方法。 Base64原理 它是用64个可打印字符表示二进制所有数据方法。由于2的6次方等于64，所以可以用每6个位元为一个单元，对应某个可打印字符。由于3个字节有24个位元，就可以刚好对应4个Base64单元，也就是说3个字节需要用到4个Base64的可打印字符来表示。在Base64中可打印的字符有A-Z、a-z、数字0-9，“+/”，就是这64个字符所对应的表如下 代码实现1234567891011121314151617181920212223242526#pragma mark - base64编码和解码// 对一个字符串进行base64编码,并且返回- (NSString *)base64EncodeString&#123; //1.先转换为二进制数据 NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding]; //2.对二进制数据进行base64编码,完成之后返回字符串 return [data base64EncodedStringWithOptions:0];&#125;// 对base64编码之后的字符串解码,并且返回-(NSString *)base64DecodeString&#123; //注意:该字符串是base64编码后的字符串 //1.转换为二进制数据(完成了解码的过程) NSData *data = [[NSData alloc]initWithBase64EncodedString:self options:0]; //2.把二进制数据在转换为字符串 return [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];&#125;/*PC端编码解码编码：base64 123.png -o 123.txt解码：base64 123.txt -o test.png -D*/ MD5加密（信息摘要算法）MD5简介 原理：MD5属于哈希算法之一，它能把任意一个长度的字节串变化成一定长度的十六进制的大整数，并且字符串的转换过程是不可逆的，不能通过加密结果反向推导原始内容，并且输出的值是唯一的。 特点： 压缩性：任意长度的数据算出的MD5值都是固定的。 抗修改性：对元数据进行任何改动，哪怕只修改一个字节所得MD5值都会有很大区别 弱抗碰撞 : 已知原数据和其 MD5 值,想找到一个具有相同 MD5 值的数据(即伪造数据)是非常困难的. 应用： 一致性验证：MD5将整个文件当做一个大文本信息,通过不可逆的字符串变换算法,产生一个唯一的MD5信息摘要.就像每个人都有自己独一无二的指纹,MD5对任何文件产生一个独一无二的数字指纹. 数字签名 安全访问认证 增加MD5破解困难度 - 加盐：先明文加盐后再进行MD5,这个拼接进来的字符串可以稍微复杂点 加密+乱序 乱序+加盐 并多次MD5 使用消息认证机制HMAC：给定一个”秘钥”，对明文进行加密，并且做”两次散列”！-&gt; 得到的结果，还是 32 个字符，相对安全 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#pragma mark - 哈希(散列)函数- (void)md5 &#123; // MD5 NSLog(@&quot;MD5加密--&gt;%@&quot;,[@&quot;123LN34*&quot; md5String]); // MD5--&gt;598eb1a985449913bfb54ed6e0a58510 // (明文+加盐)MD5 NSLog(@&quot;(明文+加盐)MD5--&gt;\\n%@&quot;,[[@&quot;123LN&quot; stringByAppendingString:salt] md5String]); // 先加密+乱序 NSLog(@&quot;先加密+乱序--&gt;\\n%@&quot;,[@&quot;123LN&quot; hmacMD5StringWithKey:@&quot;iOShangzhou&quot;]); // sha1对字符串加密 NSLog(@&quot;sha1对字符串加密--&gt;\\n%@&quot;,[@&quot;123LN&quot; sha1String]); // sha256对字符串加密 NSLog(@&quot;sha256对字符串加密--&gt;\\n%@&quot;,[@&quot;123LN&quot; sha256String]); // sha512对字符串加密 NSLog(@&quot;sha512对字符串加密--&gt;\\n%@&quot;,[@&quot;123LN&quot; sha1String]);&#125;#pragma mark - 字符串加密- (NSString *)md5String&#123; const char *str = self.UTF8String; uint8_t buffer[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), buffer); return [self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];&#125;- (NSString *)sha1String&#123; const char *str = self.UTF8String; uint8_t buffer[CC_SHA1_DIGEST_LENGTH]; CC_SHA1(str, (CC_LONG)strlen(str), buffer); return [self stringFromBytes:buffer length:CC_SHA1_DIGEST_LENGTH];&#125;- (NSString *)sha256String&#123; const char *str = self.UTF8String; uint8_t buffer[CC_SHA256_DIGEST_LENGTH]; CC_SHA256(str, (CC_LONG)strlen(str), buffer); return [self stringFromBytes:buffer length:CC_SHA256_DIGEST_LENGTH];&#125;- (NSString *)sha512String&#123; const char *str = self.UTF8String; uint8_t buffer[CC_SHA512_DIGEST_LENGTH]; CC_SHA512(str, (CC_LONG)strlen(str), buffer); return [self stringFromBytes:buffer length:CC_SHA512_DIGEST_LENGTH];&#125;#pragma mark - HMAC 字符串加密- (NSString *)hmacMD5StringWithKey:(NSString *)key&#123; const char *keyData = key.UTF8String; const char *strData = self.UTF8String; uint8_t buffer[CC_MD5_DIGEST_LENGTH]; CCHmac(kCCHmacAlgMD5, keyData, strlen(keyData), strData, strlen(strData), buffer); return [self stringFromBytes:buffer length:CC_MD5_DIGEST_LENGTH];&#125;- (NSString *)hmacSHA1StringWithKey:(NSString *)key&#123; const char *keyData = key.UTF8String; const char *strData = self.UTF8String; uint8_t buffer[CC_SHA1_DIGEST_LENGTH]; CCHmac(kCCHmacAlgSHA1, keyData, strlen(keyData), strData, strlen(strData), buffer); return [self stringFromBytes:buffer length:CC_SHA1_DIGEST_LENGTH];&#125;- (NSString *)hmacSHA256StringWithKey:(NSString *)key&#123; const char *keyData = key.UTF8String; const char *strData = self.UTF8String; uint8_t buffer[CC_SHA256_DIGEST_LENGTH]; CCHmac(kCCHmacAlgSHA256, keyData, strlen(keyData), strData, strlen(strData), buffer); return [self stringFromBytes:buffer length:CC_SHA256_DIGEST_LENGTH];&#125;- (NSString *)hmacSHA512StringWithKey:(NSString *)key&#123; const char *keyData = key.UTF8String; const char *strData = self.UTF8String; uint8_t buffer[CC_SHA512_DIGEST_LENGTH]; CCHmac(kCCHmacAlgSHA512, keyData, strlen(keyData), strData, strlen(strData), buffer); return [self stringFromBytes:buffer length:CC_SHA512_DIGEST_LENGTH];&#125; AES、DES对称加密的特点： 加密和解密过程中都是用的同一个密匙 加密和解密都是可逆的 加密过程是先加密再进行Base64码，解密过程先Base64解码再解密 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 -(void)AES&#123; // encryWithPublicKey NSString *str = [AES encrypt:@&quot;LN123&quot; keyString:@&quot;SDTUJZLI&quot;]; NSLog(@&quot;AES公钥加密数据--&gt;\\n%@&quot;,str); // decryWithPriviteKey NSString *str1 = [AES decrypt:str keyString:@&quot;SDTUJZLI&quot;]; NSLog(@&quot;AES私钥解密数据--&gt;\\n%@&quot;,str1);&#125;-(void)DES&#123; NSString *str = [DES3Util encryptUseDES:@&quot;LN123&quot; keyString:@&quot;syh&quot;]; NSLog(@&quot;DES公钥加密数据--&gt;\\n%@&quot;,str); NSString *str1 = [DES3Util decryptUseDES:str keyString:@&quot;syh&quot;]; NSLog(@&quot;DES私钥解密数据--&gt;\\n%@&quot;,str1);&#125;// AES加密字符串并返回base64编码字符串+ (NSString *)encrypt:(NSString *)string keyString:(NSString *)keyString &#123; NSData *encryptedData = [[string dataUsingEncoding:NSUTF8StringEncoding] AES256EncryptedDataUsingKey:[[keyString dataUsingEncoding:NSUTF8StringEncoding] SHA256Hash] error:nil]; NSString *base64EncodedString = [NSString base64StringFromData:encryptedData length:[encryptedData length]]; return base64EncodedString;&#125;// AES解密字符串+ (NSString *)decrypt:(NSString *)base64EncodedString keyString:(NSString *)keyString &#123; NSData *encryptedData = [NSData base64DataFromString:base64EncodedString]; NSData *decryptedData = [encryptedData decryptedAES256DataUsingKey:[[keyString dataUsingEncoding:NSUTF8StringEncoding] SHA256Hash] error:nil]; return [[NSString alloc] initWithData:decryptedData encoding:NSUTF8StringEncoding];&#125;// Des加密+(NSString *) encryptUseDES:(NSString *)string keyString:(NSString *)keyString&#123; NSString *ciphertext = nil; NSData *textData = [string dataUsingEncoding:NSUTF8StringEncoding]; NSUInteger dataLength = [textData length]; unsigned char buffer[1024]; memset(buffer, 0, sizeof(char)); size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmDES, kCCOptionPKCS7Padding, [keyString UTF8String], kCCKeySizeDES, iv, [textData bytes], dataLength, buffer, 1024, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) &#123; NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted]; ciphertext = [GTMBase64 stringByEncodingData:data]; &#125; return ciphertext;&#125;// Des解密+(NSString *)decryptUseDES:(NSString *)base64EncodedString keyString:(NSString *)keyString&#123; NSString *plaintext = nil; NSData *cipherdata = [GTMBase64 decodeString:base64EncodedString]; unsigned char buffer[1024]; memset(buffer, 0, sizeof(char)); size_t numBytesDecrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmDES, kCCOptionPKCS7Padding, [keyString UTF8String], kCCKeySizeDES, iv, [cipherdata bytes], [cipherdata length], buffer, 1024, &amp;numBytesDecrypted); if(cryptStatus == kCCSuccess) &#123; NSData *plaindata = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesDecrypted]; plaintext = [[NSString alloc]initWithData:plaindata encoding:NSUTF8StringEncoding]; &#125; return plaintext;&#125; RSARSA简介 使用公匙加密，私匙解密 使用私匙加密，公匙解密 公匙是公开的，私匙是保密的 加密安全，但性能不好 如何在生成公匙 私匙123456789# MAC上生成公钥、私钥的方法 @code 1.打开终端，切换到自己想输出的文件夹下 2.输入指令:openssl（openssl是生成各种秘钥的工具，mac已经嵌入) 3.输入指令:genrsa -out rsa_private_key.pem 1024 (生成私钥，java端使用的) 4.输入指令:rsa -in rsa_private_key.pem -out rsa_public_key.pem -pubout (生成公钥) 5.输入指令:pkcs8 -topk8 -in rsa_private_key.pem -out pkcs8_rsa_private_key.pem -nocrypt(私钥转格式，在ios端使用私钥解密时用这个私钥) 注意:在MAC上生成三个.pem格式的文件，一个公钥，两个私钥，都可以在终端通过指令vim xxx.pem 打开，里面是字符串，第三步生成的私钥是java端用来解密数据的，第五步转换格式的私钥iOS端可以用来调试公钥、私钥解密（因为私钥不留在客户端） iOS端公钥加密私钥解密、java端公钥加密私钥解密，java端私钥加密公钥解密都容易做到，iOS不能私钥加密公钥解密，只能用于验签 代码实现 123456789 @interface RSAUtil : UIViewController// 公钥加密时调用类方法：+ (NSString *)encryptString:(NSString *)str publicKey:(NSString *)pubKey;+ (NSData *)encryptData:(NSData *)data publicKey:(NSString *)pubKey;// 私钥解密时调用类方法+ (NSString *)decryptString:(NSString *)str privateKey:(NSString *)privKey;+ (NSData *)decryptData:(NSData *)data privateKey:(NSString *)privKey; 附上Demo地址 Demo地址","tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/xiaoqiang051512/xiaoqiang051512.github.io/tags/iOS/"}]},{"title":"OC常用方法","date":"2017-06-28T07:26:13.000Z","path":"2017/06/28/OC常用方法/","text":"1.禁止手机失眠[UIApplication sharedApplication].idleTimerDisabled = YES; 2.动画切换window的根控制器1234567[UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:0.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; BOOL oldState = [UIView areAnimationsEnabled]; [UIView setAnimationsEnabled:NO]; [UIApplication sharedApplication].keyWindow.rootViewController = [RootViewController new]; [UIView setAnimationsEnabled:oldState]; &#125; completion:^(BOOL finished) &#123; &#125;]; 3.去除数组中重复的对象 1NSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self&quot;]; 4.跳进app权限 12345if (UIApplicationOpenSettingsURLString != NULL) &#123; NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; [[UIApplication sharedApplication] openURL:url]; &#125; &#125; 5.开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。6.设置navigationBar上的title颜色和大小1[self.navigationController.navigationBar setTitleTextAttributes:@&#123;NSForegroundColorAttributeName : [UIColor youColor], NSFontAttributeName : [UIFont systemFontOfSize:15]&#125;] 7.颜色转照片12345678910111213+ (UIImage *)cl_imageWithColor:(UIColor *)color &#123; CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 8.强/弱引用12#define WeakSelf(type) __weak typeof(type) weak##type = type; // weak#define StrongSelf(type) __strong typeof(type) type = weak##type; // strong 9.获取图片资源1#define GetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@&quot;%@&quot;,imageName]] 10.角度转弧度1#define DegreesToRadian(x) (M_PI * (x) / 180.0) 11.弧度转角度1#define RadianToDegrees(radian) (radian*180.0)/(M_PI) 12.获取temp1#define PathTemp NSTemporaryDirectory() 13. 获取沙盒 Document1#define PathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject] 14. 获取沙盒 Cache1#define PathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject] 15.GCD只执行一次1#define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock); 16.自定义NSLog12345#ifdef DEBUG#define NSLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)#else#define NSLog(...)#endif 17.Font12345#define FontL(s) [UIFont systemFontOfSize:s weight:UIFontWeightLight]#define FontR(s) [UIFont systemFontOfSize:s weight:UIFontWeightRegular]#define FontB(s) [UIFont systemFontOfSize:s weight:UIFontWeightBold]#define FontT(s) [UIFont systemFontOfSize:s weight:UIFontWeightThin]#define Font(s) FontL(s) 18.在主线程上运行1#define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock); 19.开启异步线程1#define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl); 20.通知123#define NOTIF_ADD(n, f) [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(f) name:n object:nil]#define NOTIF_POST(n, o) [[NSNotificationCenter defaultCenter] postNotificationName:n object:o]#define NOTIF_REMV() [[NSNotificationCenter defaultCenter] removeObserver:self] 21.获取window123456789101112+(UIWindow*)getWindow &#123; UIWindow* win = nil; //[UIApplication sharedApplication].keyWindow; for (id item in [UIApplication sharedApplication].windows) &#123; if ([item class] == [UIWindow class]) &#123; if (!((UIWindow*)item).hidden) &#123; win = item; break; &#125; &#125; &#125; return win;&#125; 22.修改textField的PlaceHold的字体颜色和大小12[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@&quot;_placeholderLabel.font&quot;]; 23.统一手气键盘1[[[UIApplication sharedApplication] keyWindow] endEditing:YES]; 24.获取app缓存大小12345678910111213141516171819- (CGFloat)getCachSize &#123; NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize]; //获取自定义缓存大小 //用枚举器遍历 一个文件夹的内容 //1.获取 文件夹枚举器 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;]; NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath]; __block NSUInteger count = 0; //2.遍历 for (NSString *fileName in enumerator) &#123; NSString *path = [myCachePath stringByAppendingPathComponent:fileName]; NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil]; count += fileDict.fileSize;//自定义所有缓存大小 &#125; // 得到是字节 转化为M CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024; return totalSize;&#125; 25.清理app缓存1234567891011- (void)handleClearView &#123; //删除两部分 //1.删除 sd 图片缓存 //先清除内存中的图片缓存 [[SDImageCache sharedImageCache] clearMemory]; //清除磁盘的缓存 [[SDImageCache sharedImageCache] clearDisk]; //2.删除自己缓存 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;]; [[NSFileManager defaultManager] removeItemAtPath:myCachePath error:nil];&#125; 26.模型转字典123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static NSSet *classes; - (NSMutableDictionary *)getParameterDictionary &#123; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; Class c = self.class; while (c) &#123; unsigned count; objc_property_t *properties = class_copyPropertyList([c class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; NSString *key = [NSString stringWithUTF8String:property_getName(properties[i])]; dict[key] = [self valueForKey:key]; &#125; free(properties); // 获得父类 c = class_getSuperclass(c); if ([self isClassFromFoundation:c]) break; &#125; return dict;&#125; - (BOOL)isClassFromFoundation:(Class)c&#123; if (c == [NSObject class] || c == [NSManagedObject class]) return YES; __block BOOL result = NO; [[self foundationClasses] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) &#123; if ([c isSubclassOfClass:foundationClass]) &#123; result = YES; *stop = YES; &#125; &#125;]; return result;&#125; - (NSSet *)foundationClasses&#123; if (classes == nil) &#123; // 集合中没有NSObject，因为几乎所有的类都是继承自NSObject，具体是不是NSObject需要特殊判断 classes = [NSSet setWithObjects: [NSURL class], [NSDate class], [NSValue class], [NSData class], [NSError class], [NSArray class], [NSDictionary class], [NSString class], [NSAttributedString class], nil]; &#125; return classes;&#125; 27.交换两个方法实现12345678910111213141516171819202122Class aClass = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(aClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); BOOL didAddMethod = class_addMethod(aClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(aClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; ####### 28.常用权限判断1234567891011121314151617if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) &#123; NSLog(@&quot;没有定位权限&quot;); &#125; AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (statusVideo == AVAuthorizationStatusDenied) &#123; NSLog(@&quot;没有摄像头权限&quot;); &#125; //是否有麦克风权限 AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio]; if (statusAudio == AVAuthorizationStatusDenied) &#123; NSLog(@&quot;没有录音权限&quot;); &#125; [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) &#123; if (status == PHAuthorizationStatusDenied) &#123; NSLog(@&quot;没有相册权限&quot;); &#125; &#125;]; 29.获取手机型号1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 + (NSString *)getDeviceInfo &#123; struct utsname systemInfo; uname(&amp;systemInfo); NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding]; if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;; if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;; if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;; if ([platform isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;; if ([platform isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;; if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;; if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;; // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付 if ([platform isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;国行、日版、港行iPhone 7&quot;; if ([platform isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;港行、国行iPhone 7 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;美版、台版iPhone 7&quot;; if ([platform isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;美版、台版iPhone 7 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;; if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;; if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;; if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;; if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;; if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch 5G&quot;; if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2G&quot;; if ([platform isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2G&quot;; if ([platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2G&quot;; if ([platform isEqualToString:@&quot;i386&quot;]) return @&quot;iPhone Simulator&quot;; if ([platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;; return platform;&#125; 30.长按复制功能12345678910- (void)viewDidLoad&#123; [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];&#125;- (void)pasteBoard:(UILongPressGestureRecognizer *)longPress &#123; if (longPress.state == UIGestureRecognizerStateBegan) &#123; UIPasteboard *pasteboard = [UIPasteboard generalPasteboard]; pasteboard.string = @&quot;需要复制的文本&quot;; &#125;&#125; 31.判断图片类型12345678910111213141516171819202122232425262728293031323334353637//通过图片Data数据第一个字节 来获取图片扩展名- (NSString *)contentTypeForImageData:(NSData *)data&#123; uint8_t c; [data getBytes:&amp;c length:1]; switch (c) &#123; case 0xFF: return @&quot;jpeg&quot;; case 0x89: return @&quot;png&quot;; case 0x47: return @&quot;gif&quot;; case 0x49: case 0x4D: return @&quot;tiff&quot;; case 0x52: if ([data length] &lt; 12) &#123; return nil; &#125; NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding]; if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123; return @&quot;webp&quot;; &#125; return nil; &#125; return nil;&#125; 32.获取手机和app信息12345678910111213141516171819202122232425262728293031323334353637383940NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; CFShow(infoDictionary); // app名称 NSString *app_Name = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;]; // app版本 NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;]; // app build版本 NSString *app_build = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;]; //手机序列号 NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier]; NSLog(@&quot;手机序列号: %@&quot;,identifierNumber); //手机别名： 用户定义的名称 NSString* userPhoneName = [[UIDevice currentDevice] name]; NSLog(@&quot;手机别名: %@&quot;, userPhoneName); //设备名称 NSString* deviceName = [[UIDevice currentDevice] systemName]; NSLog(@&quot;设备名称: %@&quot;,deviceName ); //手机系统版本 NSString* phoneVersion = [[UIDevice currentDevice] systemVersion]; NSLog(@&quot;手机系统版本: %@&quot;, phoneVersion); //手机型号 NSString* phoneModel = [[UIDevice currentDevice] model]; NSLog(@&quot;手机型号: %@&quot;,phoneModel ); //地方型号 （国际化区域名称） NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel]; NSLog(@&quot;国际化区域名称: %@&quot;,localPhoneModel ); NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; // 当前应用名称 NSString *appCurName = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;]; NSLog(@&quot;当前应用名称：%@&quot;,appCurName); // 当前应用软件版本 比如：1.0.1 NSString *appCurVersion = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;]; NSLog(@&quot;当前应用软件版本:%@&quot;,appCurVersion); // 当前应用版本号码 int类型 NSString *appCurVersionNum = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;]; NSLog(@&quot;当前应用版本号码：%@&quot;,appCurVersionNum); 33.获取一个类的所有属性1234567id LenderClass = objc_getClass(&quot;Lender&quot;);unsigned int outCount, i;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);for (i = 0; i &lt; outCount; i++) &#123; objc_property_t property = properties[i]; fprintf(stdout, &quot;%s %s\\n&quot;, property_getName(property), property_getAttributes(property));&#125; 34.image的圆角123456789101112131415161718- (UIImage *)circleImage&#123; // NO代表透明 UIGraphicsBeginImageContextWithOptions(self.size, NO, 1); // 获得上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 添加一个圆 CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); // 方形变圆形 CGContextAddEllipseInRect(ctx, rect); // 裁剪 CGContextClip(ctx); // 将图片画上去 [self drawInRect:rect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 35.image拉伸123456+ (UIImage *)resizableImage:(NSString *)imageName&#123; UIImage *image = [UIImage imageNamed:imageName]; CGFloat imageW = image.size.width; CGFloat imageH = image.size.height; return [image resizableImageWithCapInsets:UIEdgeInsetsMake(imageH * 0.5, imageW * 0.5, imageH * 0.5, imageW * 0.5) resizingMode:UIImageResizingModeStretch]; 36.Json字符转字典12345+ (NSDictionary *)parseJSONStringToNSDictionary:(NSString *)JSONString &#123; NSData *JSONData = [JSONString dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingMutableLeaves error:nil]; return responseJSON;&#125; 37.身份证号验证12345678910- (BOOL)validateIdentityCard &#123; BOOL flag; if (self.length &lt;= 0) &#123; flag = NO; return flag; &#125; NSString *regex2 = @&quot;^(\\\\d&#123;14&#125;|\\\\d&#123;17&#125;)(\\\\d|[xX])$&quot;; NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,regex2]; return [identityCardPredicate evaluateWithObject:self];&#125; 38.获取mac地址12345678910111213141516171819202122232425262728293031323334353637383940414243+ (NSString *)macAddress &#123; int mib[6]; size_t len; char *buf; unsigned char *ptr; struct if_msghdr *ifm; struct sockaddr_dl *sdl; mib[0] = CTL_NET; mib[1] = AF_ROUTE; mib[2] = 0; mib[3] = AF_LINK; mib[4] = NET_RT_IFLIST; if((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123; printf(&quot;Error: if_nametoindex error\\n&quot;); return NULL; &#125; if(sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123; printf(&quot;Error: sysctl, take 1\\n&quot;); return NULL; &#125; if((buf = malloc(len)) == NULL) &#123; printf(&quot;Could not allocate memory. Rrror!\\n&quot;); return NULL; &#125; if(sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123; printf(&quot;Error: sysctl, take 2&quot;); return NULL; &#125; ifm = (struct if_msghdr *)buf; sdl = (struct sockaddr_dl *)(ifm + 1); ptr = (unsigned char *)LLADDR(sdl); NSString *outstring = [NSString stringWithFormat:@&quot;X:X:X:X:X:X&quot;, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)]; free(buf); return outstring;&#125; 39.拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到12345678910111213- (UIViewController *)getVisibleViewControllerFrom:(UIViewController*)vc &#123; if ([vc isKindOfClass:[UINavigationController class]]) &#123; return [self getVisibleViewControllerFrom:[((UINavigationController*) vc) visibleViewController]]; &#125;else if ([vc isKindOfClass:[UITabBarController class]])&#123; return [self getVisibleViewControllerFrom:[((UITabBarController*) vc) selectedViewController]]; &#125; else &#123; if (vc.presentedViewController) &#123; return [self getVisibleViewControllerFrom:vc.presentedViewController]; &#125; else &#123; return vc; &#125; &#125;&#125; 40.runtime动态增加一个属性 以及获取动态增加的属性123// 动态添加属性的本质是: 让对象的某个属性与值产生关联 objc_setAssociatedObject(self, WZBPlaceholderViewKey, placeholderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC); objc_getAssociatedObject(self, WZBPlaceholderViewKey); 41.KVO监听某个对象的属性12345678910// 添加监听者[self addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:nil]; // 当监听的属性值变化的时候会来到这个方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if ([keyPath isEqualToString:@&quot;property&quot;]) &#123; [self textViewTextChange]; &#125; else &#123; &#125;&#125; 42.Reachability判断网络状态12345678910NetworkStatus status = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus]; if (status == NotReachable) &#123; NSLog(@&quot;当前设备无网络&quot;); &#125; if (status == ReachableViaWiFi) &#123; NSLog(@&quot;当前wifi网络&quot;); &#125; if (status == NotReachable) &#123; NSLog(@&quot;当前蜂窝移动网络&quot;); &#125; 43.AFNetworking监听网络状态123456789101112131415161718192021// 监听网络状况 AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager]; [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; switch (status) &#123; case AFNetworkReachabilityStatusUnknown: break; case AFNetworkReachabilityStatusNotReachable: &#123; [SVProgressHUD showInfoWithStatus:@&quot;当前设备无网络&quot;]; &#125; break; case AFNetworkReachabilityStatusReachableViaWiFi: [SVProgressHUD showInfoWithStatus:@&quot;当前Wi-Fi网络&quot;]; break; case AFNetworkReachabilityStatusReachableViaWWAN: [SVProgressHUD showInfoWithStatus:@&quot;当前蜂窝移动网络&quot;]; break; default: break; &#125; &#125;]; [mgr startMonitoring]; 44.取图片某一点的颜色12345678910111213141516171819202122232425262728293031323334353637383940if (point.x &lt; 0 || point.y &lt; 0) return nil; CGImageRef imageRef = self.CGImage; NSUInteger width = CGImageGetWidth(imageRef); NSUInteger height = CGImageGetHeight(imageRef); if (point.x &gt;= width || point.y &gt;= height) return nil; unsigned char *rawData = malloc(height * width * 4); if (!rawData) return nil; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel * width; NSUInteger bitsPerComponent = 8; CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); if (!context) &#123; free(rawData); return nil; &#125; CGColorSpaceRelease(colorSpace); CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGContextRelease(context); int byteIndex = (bytesPerRow * point.y) + point.x * bytesPerPixel; CGFloat red = (rawData[byteIndex] * 1.0) / 255.0; CGFloat green = (rawData[byteIndex + 1] * 1.0) / 255.0; CGFloat blue = (rawData[byteIndex + 2] * 1.0) / 255.0; CGFloat alpha = (rawData[byteIndex + 3] * 1.0) / 255.0; UIColor *result = nil; result = [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; free(rawData); return result; 45.判断图片是否有透明度12345678 - (BOOL)hasAlphaChannel&#123; CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage); return (alpha == kCGImageAlphaFirst || alpha == kCGImageAlphaLast || alpha == kCGImageAlphaPremultipliedFirst || alpha == kCGImageAlphaPremultipliedLast);&#125; 46.获得灰度图123456789101112131415161718192021+ (UIImage*)covertToGrayImageFromImage:(UIImage*)sourceImage&#123; int width = sourceImage.size.width; int height = sourceImage.size.height; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray(); CGContextRef context = CGBitmapContextCreate (nil,width,height,8,0,colorSpace,kCGImageAlphaNone); CGColorSpaceRelease(colorSpace); if (context == NULL) &#123; return nil; &#125; CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage); CGImageRef contextRef = CGBitmapContextCreateImage(context); UIImage *grayImage = [UIImage imageWithCGImage:contextRef]; CGContextRelease(context); CGImageRelease(contextRef); return grayImage;&#125; 47.根据bundle中的文件名读取图片12345678910111213141516171819202122232425262728293031323334353637 + (UIImage *)imageWithFileName:(NSString *)name &#123; NSString *extension = @&quot;png&quot;; NSArray *components = [name componentsSeparatedByString:@&quot;.&quot;]; if ([components count] &gt;= 2) &#123; NSUInteger lastIndex = components.count - 1; extension = [components objectAtIndex:lastIndex]; name = [name substringToIndex:(name.length-(extension.length+1))]; &#125; // 如果为Retina屏幕且存在对应图片，则返回Retina图片，否则查找普通图片 if ([UIScreen mainScreen].scale == 2.0) &#123; name = [name stringByAppendingString:@&quot;@2x&quot;]; NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension]; if (path != nil) &#123; return [UIImage imageWithContentsOfFile:path]; &#125; &#125; if ([UIScreen mainScreen].scale == 3.0) &#123; name = [name stringByAppendingString:@&quot;@3x&quot;]; NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension]; if (path != nil) &#123; return [UIImage imageWithContentsOfFile:path]; &#125; &#125; NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension]; if (path) &#123; return [UIImage imageWithContentsOfFile:path]; &#125; return nil;&#125; 48.合并两个图片123456789101112131415+ (UIImage*)mergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage &#123; CGImageRef firstImageRef = firstImage.CGImage; CGFloat firstWidth = CGImageGetWidth(firstImageRef); CGFloat firstHeight = CGImageGetHeight(firstImageRef); CGImageRef secondImageRef = secondImage.CGImage; CGFloat secondWidth = CGImageGetWidth(secondImageRef); CGFloat secondHeight = CGImageGetHeight(secondImageRef); CGSize mergedSize = CGSizeMake(MAX(firstWidth, secondWidth), MAX(firstHeight, secondHeight)); UIGraphicsBeginImageContext(mergedSize); [firstImage drawInRect:CGRectMake(0, 0, firstWidth, firstHeight)]; [secondImage drawInRect:CGRectMake(0, 0, secondWidth, secondHeight)]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 49.为imageView添加倒影1234567891011121314151617181920212223CGRect frame = self.frame; frame.origin.y += (frame.size.height + 1); UIImageView *reflectionImageView = [[UIImageView alloc] initWithFrame:frame]; self.clipsToBounds = TRUE; reflectionImageView.contentMode = self.contentMode; [reflectionImageView setImage:self.image]; reflectionImageView.transform = CGAffineTransformMakeScale(1.0, -1.0); CALayer *reflectionLayer = [reflectionImageView layer]; CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.bounds = reflectionLayer.bounds; gradientLayer.position = CGPointMake(reflectionLayer.bounds.size.width / 2, reflectionLayer.bounds.size.height * 0.5); gradientLayer.colors = [NSArray arrayWithObjects: (id)[[UIColor clearColor] CGColor], (id)[[UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.3] CGColor], nil]; gradientLayer.startPoint = CGPointMake(0.5,0.5); gradientLayer.endPoint = CGPointMake(0.5,1.0); reflectionLayer.mask = gradientLayer; [self.superview addSubview:reflectionImageView]; 50.为图片添加水印1234567891011121314- (void) setImage:(UIImage *)image withWaterMark:(UIImage *)mark inRect:(CGRect)rect&#123; if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 4.0) &#123; UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0); &#125; //原图 [image drawInRect:self.bounds]; //水印图 [mark drawInRect:rect]; UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); self.image = newPic;&#125; 51.让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950自定义UILabel// 重写label的textRectForBounds方法- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines &#123; CGRect rect = [super textRectForBounds:bounds limitedToNumberOfLines:numberOfLines]; switch (self.textAlignmentType) &#123; case WZBTextAlignmentTypeLeftTop: &#123; rect.origin = bounds.origin; &#125; break; case WZBTextAlignmentTypeRightTop: &#123; rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, bounds.origin.y); &#125; break; case WZBTextAlignmentTypeLeftBottom: &#123; rect.origin = CGPointMake(bounds.origin.x, CGRectGetMaxY(bounds) - rect.size.height); &#125; break; case WZBTextAlignmentTypeRightBottom: &#123; rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, CGRectGetMaxY(bounds) - rect.size.height); &#125; break; case WZBTextAlignmentTypeTopCenter: &#123; rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - rect.origin.y); &#125; break; case WZBTextAlignmentTypeBottomCenter: &#123; rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - CGRectGetMaxY(bounds) - rect.size.height); &#125; break; case WZBTextAlignmentTypeLeft: &#123; rect.origin = CGPointMake(0, rect.origin.y); &#125; break; case WZBTextAlignmentTypeRight: &#123; rect.origin = CGPointMake(rect.origin.x, 0); &#125; break; case WZBTextAlignmentTypeCenter: &#123; rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, (CGRectGetHeight(bounds) - CGRectGetHeight(rect)) / 2); &#125; break; default: break; &#125; return rect;&#125;- (void)drawTextInRect:(CGRect)rect &#123; CGRect textRect = [self textRectForBounds:rect limitedToNumberOfLines:self.numberOfLines]; [super drawTextInRect:textRect];&#125; 52.移除字符串中的空格和换行123456+ (NSString *)removeSpaceAndNewline:(NSString *)str &#123; NSString *temp = [str stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; temp = [temp stringByReplacingOccurrencesOfString:@&quot;\\r&quot; withString:@&quot;&quot;]; temp = [temp stringByReplacingOccurrencesOfString:@&quot;\\n&quot; withString:@&quot;&quot;]; return temp;&#125; 53.判断字符串中是否有空格12345678910+ (BOOL)isBlank:(NSString *)str &#123; NSRange _range = [str rangeOfString:@&quot; &quot;]; if (_range.location != NSNotFound) &#123; //有空格 return YES; &#125; else &#123; //没有空格 return NO; &#125;&#125; 54.获取视屏第一帧12345678910NSURL *url = [NSURL URLWithString:filepath]; AVURLAsset *asset1 = [[AVURLAsset alloc] initWithURL:url options:nil]; AVAssetImageGenerator *generate1 = [[AVAssetImageGenerator alloc] initWithAsset:asset1]; generate1.appliesPreferredTrackTransform = YES; NSError *err = NULL; CMTime time = CMTimeMake(1, 2); CGImageRef oneRef = [generate1 copyCGImageAtTime:time actualTime:NULL error:&amp;err]; UIImage *one = [[UIImage alloc] initWithCGImage:oneRef]; return one; 55.获取视频的时长1234567+ (NSInteger)getVideoTimeByUrlString:(NSString *)urlString &#123; NSURL *videoUrl = [NSURL URLWithString:urlString]; AVURLAsset *avUrl = [AVURLAsset assetWithURL:videoUrl]; CMTime time = [avUrl duration]; int seconds = ceil(time.value/time.timescale); return seconds;&#125; 56.字符串是否为空123+ (BOOL)isEqualToNil:(NSString *)str &#123; return str.length &lt;= 0 || [str isEqualToString:@&quot;&quot;] || !str;&#125; 57.删除NSUserDefaults所有记录1234567891011121314//方法一 NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier]; [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain]; //方法二 - (void)resetDefaults &#123; NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) &#123; [defs removeObjectForKey:key]; &#125; [defs synchronize]; &#125;// 方法三[[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]]; 58.禁用系统滑动返回功能12345678910111213141516- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated];if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) &#123;self.navigationController.interactivePopGestureRecognizer.delegate = self; &#125;&#125; - (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) &#123;self.navigationController.interactivePopGestureRecognizer.delegate = nil; &#125;&#125;- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer&#123; return NO;&#125; 59.UILabel设置内边距123456子类化UILabel，重写drawTextInRect方法- (void)drawTextInRect:(CGRect)rect &#123; // 边距，上左下右 UIEdgeInsets insets = &#123;0, 5, 0, 5&#125;; [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];&#125; 60.UILabel设置文字描边12345678910111213141516子类化UILabel，重写drawTextInRect方法- (void)drawTextInRect:(CGRect)rect&#123; CGContextRef c = UIGraphicsGetCurrentContext(); // 设置描边宽度 CGContextSetLineWidth(c, 1); CGContextSetLineJoin(c, kCGLineJoinRound); CGContextSetTextDrawingMode(c, kCGTextStroke); // 描边颜色 self.textColor = [UIColor redColor]; [super drawTextInRect:rect]; // 文本颜色 self.textColor = [UIColor yellowColor]; CGContextSetTextDrawingMode(c, kCGTextFill); [super drawTextInRect:rect];&#125; ####### 61 scrollView滚动到最下边12CGPoint bottomOffset = CGPointMake(0, scrollView.contentSize.height - scrollView.bounds.size.height);[scrollView setContentOffset:bottomOffset animated:YES]; ####### 62 摇一摇功能1234567891011121、打开摇一摇功能 [UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;2、让需要摇动的控制器成为第一响应者[self becomeFirstResponder];3、实现以下方法 // 开始摇动- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event// 取消摇动- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event// 摇动结束- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event 63.获取图片大小12CGFloat imageWidth = image.size.width; CGFloat imageHeight = imageWidth * image.scale; ####### 64.修改UISegmentedControl的字体大小1[segment setTitleTextAttributes:@&#123;NSFontAttributeName : [UIFont systemFontOfSize:15.0f]&#125; forState:UIControlStateNormal]; 65.获取一个view所属的控制器12345678910// view分类方法- (UIViewController *)belongViewController &#123; for (UIView *next = [self superview]; next; next = next.superview) &#123; UIResponder* nextResponder = [next nextResponder]; if ([nextResponder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)nextResponder; &#125; &#125; return nil;&#125; 66.在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花1[UIApplication sharedApplication].networkActivityIndicatorVisible = YES; 67.将一个image保存在相册中1234567891011121314UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);或者#import[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123; PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:image]; changeRequest.creationDate = [NSDate date]; &#125; completionHandler:^(BOOL success, NSError *error) &#123; if (success) &#123; NSLog(@&quot;successfully saved&quot;); &#125; else &#123; NSLog(@&quot;error saving to photos: %@&quot;, error); &#125; &#125;]; 68.UITextView中打开或禁用复制，剪切，选择，全选等功能12345678910111213141516171819- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123;// 返回NO为禁用，YES为开启 // 粘贴 if (action == @selector(paste:)) return NO; // 剪切 if (action == @selector(cut:)) return NO; // 复制 if (action == @selector(copy:)) return NO; // 选择 if (action == @selector(select:)) return NO; // 选中全部 if (action == @selector(selectAll:)) return NO; // 删除 if (action == @selector(delete:)) return NO; // 分享 if (action == @selector(share)) return NO; return [super canPerformAction:action withSender:sender];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/xiaoqiang051512/xiaoqiang051512.github.io/tags/iOS/"}]},{"title":"GithubPages+Hexo+Next搭建博客","date":"2017-05-10T03:59:15.000Z","path":"2017/05/10/我的博客的起源/","text":"前言我想成为一个优秀的程序员，然而在技术成长和人生成长的时候必然会有许多感悟，而这些感悟是让人走的更远的利器，而个人博客是记录这些感悟的的一个不错的选择。所以我想用博客来记录我成长的点点滴滴！！！ 搭建博客的准备我选择的是GithubPages + Hexo + Next,这一种简单高效的方式实现。主要记录Mac系统搭建个人博客的详解。 搭建博客工具在Mac系统下搭建的： Xcode因为从事iOS开发的原因，Mac上已经安装了Xocde，然而Xocde集成了Git，所以就直接省略了下载Git的步骤，如果为Mac系统上未安装Xcode可以去 Git官网下载 Node.js上述步骤完成接下来是安装Node.js官网下载程序 Hexo接下来主角登场，安装Hexo 1npm install hexo-cli -g 若出现安装命令不成功，出现如下错误 解决方法：可输入下面的命令和密码继续完成安装 1sudo npm install --unsafe-perm --verbose 博客本地仓库 Github上创建分支按照下面方式在github创建github的仓库 在你的本地创建一个博客文件夹，打开终端进入到你刚刚创建的目录下，在终端进入到该目录，然后执行Hexo命令，初始化本地博客仓库:1hexo init 你的Github用户名.github.io 注意：这里初始化的时候一定要按上述格式创建，不然可能会初始化不成功，在这里踩过坑，所以记忆犹新。 博客初步完成上述步骤顺利完成后，自己的博客框架就已经基本搭建完成了，Hexo安装后默认使用的是landscape主题，终端进入到你博客的博客本地仓库中 1hexo s --debug 博客的的预览地址就是上述图片中的 http://localhost:4000/.在浏览器输入上述地址，会惊喜的见到如下的模样，有木有很惊喜 Hexo的主题在终端进入到博客本地仓库下，执行下面的命令，等待主题的下载完成 1git clone https://github.com/iissnan/hexo-theme-next themes/next Next主题已经下载完成了，接下来是配置主题了，这里需要细心的一步一步的配置。 上面这个这个是Hexo主站的配置文件,可以直接用用系统的文本编辑器进行编辑,注意编辑时需要与前面参数空一格，首先我们需要将博客地址制定到Github里面，如下图： 注意：这里是repository:更改成你github那个仓库的地址 上述图片已经的样式，里面可以配置关于自己的信息以及其他关键信息，接下俩的重点是主题的配置，打开我们先前下载的Next的主题配置文件，如下图 在主题配置文件可以设置各种信息！可以编辑这个文件进行各种设置，配出你喜欢的博客界面 其他如何写博客我博客是准备用Markdown来写，但是如何在Hexo里面如何写呢？这就需要用Hexo-admin这个插件1npm install --save hexo-admin hexo server -d 完成后就可以在浏览器输入：http://localhost:4000/admin进行在写书写博客了 但是需要注意的是这里需要你申请账号和密码，在主站的配置文件加入下面几行代码,自己写上name和password，这个在你登录 http://localhost:4000/admin 需要用到的 Markdown语言标题“# 标题” 表示一级标题“## 标题”表示二级标题以此类推 “###### 标题”表示六级标题 注意：”#”和【标题】之间建议保留一个字符的空格，这是标准的Markdown写法 列表列表有两种表达形式 - 和 1.来表示，例如“- 文本1”“- 文本2”“1. 文本1”“2. 文本2” 链接和图片“[链接显示的文字] (网址)” 这种格式显示的是链接的语法“! [image] (图片Url)”这种格式显示的是图片的语法 引用“&gt;” 表示一级引用“&gt; &gt;”表示二级引用“&gt;&gt;&gt;”表示三级引用 粗体和斜体Markdown的粗体和斜体很简单，粗体用 两个 星号包含一段文字 ，斜体用 * 包含一段文字就好, 代码引用需要引用 “```”包含代码块就好了 如何往Markdown加载本地图片可以通过七牛,进行图片处理得到图片的Url往博客里面插入","tags":[{"name":"其它","slug":"其它","permalink":"https://github.com/xiaoqiang051512/xiaoqiang051512.github.io/tags/其它/"}]},{"title":"Hello World","date":"2017-04-19T06:27:04.000Z","path":"2017/04/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"其它","slug":"其它","permalink":"https://github.com/xiaoqiang051512/xiaoqiang051512.github.io/tags/其它/"}]}]