[{"title":"iOS数据浅谈","date":"2017-06-28T08:13:56.000Z","path":"2017/06/28/iOS数据浅谈/","text":"前言数据是非常重要的东西，在网络传输或者本地存储中一些重要的敏感的数据信息需要进行加密处理","tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/xiaoqiang051512/xiaoqiang051512.github.io/tags/iOS/"}]},{"title":"OC常用方法","date":"2017-06-28T07:26:13.000Z","path":"2017/06/28/OC常用方法/","text":"1.禁止手机失眠[UIApplication sharedApplication].idleTimerDisabled = YES; 2.动画切换window的根控制器1234567[UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:0.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; BOOL oldState = [UIView areAnimationsEnabled]; [UIView setAnimationsEnabled:NO]; [UIApplication sharedApplication].keyWindow.rootViewController = [RootViewController new]; [UIView setAnimationsEnabled:oldState]; &#125; completion:^(BOOL finished) &#123; &#125;]; 3.去除数组中重复的对象 1NSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self&quot;]; 4.跳进app权限 12345if (UIApplicationOpenSettingsURLString != NULL) &#123; NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; [[UIApplication sharedApplication] openURL:url]; &#125; &#125; 5.开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。6.设置navigationBar上的title颜色和大小1[self.navigationController.navigationBar setTitleTextAttributes:@&#123;NSForegroundColorAttributeName : [UIColor youColor], NSFontAttributeName : [UIFont systemFontOfSize:15]&#125;] 7.颜色转照片12345678910111213+ (UIImage *)cl_imageWithColor:(UIColor *)color &#123; CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 8.强/弱引用12#define WeakSelf(type) __weak typeof(type) weak##type = type; // weak#define StrongSelf(type) __strong typeof(type) type = weak##type; // strong 9.获取图片资源1#define GetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@&quot;%@&quot;,imageName]] 10.角度转弧度1#define DegreesToRadian(x) (M_PI * (x) / 180.0) 11.弧度转角度1#define RadianToDegrees(radian) (radian*180.0)/(M_PI) 12.获取temp1#define PathTemp NSTemporaryDirectory() 13. 获取沙盒 Document1#define PathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject] 14. 获取沙盒 Cache1#define PathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject] 15.GCD只执行一次1#define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock); 16.自定义NSLog12345#ifdef DEBUG#define NSLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)#else#define NSLog(...)#endif 17.Font12345#define FontL(s) [UIFont systemFontOfSize:s weight:UIFontWeightLight]#define FontR(s) [UIFont systemFontOfSize:s weight:UIFontWeightRegular]#define FontB(s) [UIFont systemFontOfSize:s weight:UIFontWeightBold]#define FontT(s) [UIFont systemFontOfSize:s weight:UIFontWeightThin]#define Font(s) FontL(s) 18.在主线程上运行1#define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock); 19.开启异步线程1#define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl); 20.通知123#define NOTIF_ADD(n, f) [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(f) name:n object:nil]#define NOTIF_POST(n, o) [[NSNotificationCenter defaultCenter] postNotificationName:n object:o]#define NOTIF_REMV() [[NSNotificationCenter defaultCenter] removeObserver:self] 21.获取window123456789101112+(UIWindow*)getWindow &#123; UIWindow* win = nil; //[UIApplication sharedApplication].keyWindow; for (id item in [UIApplication sharedApplication].windows) &#123; if ([item class] == [UIWindow class]) &#123; if (!((UIWindow*)item).hidden) &#123; win = item; break; &#125; &#125; &#125; return win;&#125; 22.修改textField的PlaceHold的字体颜色和大小12[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@&quot;_placeholderLabel.font&quot;]; 23.统一手气键盘1[[[UIApplication sharedApplication] keyWindow] endEditing:YES]; 24.获取app缓存大小12345678910111213141516171819- (CGFloat)getCachSize &#123; NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize]; //获取自定义缓存大小 //用枚举器遍历 一个文件夹的内容 //1.获取 文件夹枚举器 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;]; NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath]; __block NSUInteger count = 0; //2.遍历 for (NSString *fileName in enumerator) &#123; NSString *path = [myCachePath stringByAppendingPathComponent:fileName]; NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil]; count += fileDict.fileSize;//自定义所有缓存大小 &#125; // 得到是字节 转化为M CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024; return totalSize;&#125; 25.清理app缓存1234567891011- (void)handleClearView &#123; //删除两部分 //1.删除 sd 图片缓存 //先清除内存中的图片缓存 [[SDImageCache sharedImageCache] clearMemory]; //清除磁盘的缓存 [[SDImageCache sharedImageCache] clearDisk]; //2.删除自己缓存 NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;]; [[NSFileManager defaultManager] removeItemAtPath:myCachePath error:nil];&#125; 26.模型转字典123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static NSSet *classes; - (NSMutableDictionary *)getParameterDictionary &#123; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; Class c = self.class; while (c) &#123; unsigned count; objc_property_t *properties = class_copyPropertyList([c class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; NSString *key = [NSString stringWithUTF8String:property_getName(properties[i])]; dict[key] = [self valueForKey:key]; &#125; free(properties); // 获得父类 c = class_getSuperclass(c); if ([self isClassFromFoundation:c]) break; &#125; return dict;&#125; - (BOOL)isClassFromFoundation:(Class)c&#123; if (c == [NSObject class] || c == [NSManagedObject class]) return YES; __block BOOL result = NO; [[self foundationClasses] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) &#123; if ([c isSubclassOfClass:foundationClass]) &#123; result = YES; *stop = YES; &#125; &#125;]; return result;&#125; - (NSSet *)foundationClasses&#123; if (classes == nil) &#123; // 集合中没有NSObject，因为几乎所有的类都是继承自NSObject，具体是不是NSObject需要特殊判断 classes = [NSSet setWithObjects: [NSURL class], [NSDate class], [NSValue class], [NSData class], [NSError class], [NSArray class], [NSDictionary class], [NSString class], [NSAttributedString class], nil]; &#125; return classes;&#125; 27.交换两个方法实现12345678910111213141516171819202122Class aClass = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(aClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); BOOL didAddMethod = class_addMethod(aClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(aClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; ####### 28.常用权限判断1234567891011121314151617if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) &#123; NSLog(@&quot;没有定位权限&quot;); &#125; AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (statusVideo == AVAuthorizationStatusDenied) &#123; NSLog(@&quot;没有摄像头权限&quot;); &#125; //是否有麦克风权限 AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio]; if (statusAudio == AVAuthorizationStatusDenied) &#123; NSLog(@&quot;没有录音权限&quot;); &#125; [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) &#123; if (status == PHAuthorizationStatusDenied) &#123; NSLog(@&quot;没有相册权限&quot;); &#125; &#125;]; 29.获取手机型号1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 + (NSString *)getDeviceInfo &#123; struct utsname systemInfo; uname(&amp;systemInfo); NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding]; if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;; if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;; if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;; if ([platform isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;; if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;; if ([platform isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;; if ([platform isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;; if ([platform isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;; if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;; if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;; if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;; // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付 if ([platform isEqualToString:@&quot;iPhone9,1&quot;]) return @&quot;国行、日版、港行iPhone 7&quot;; if ([platform isEqualToString:@&quot;iPhone9,2&quot;]) return @&quot;港行、国行iPhone 7 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone9,3&quot;]) return @&quot;美版、台版iPhone 7&quot;; if ([platform isEqualToString:@&quot;iPhone9,4&quot;]) return @&quot;美版、台版iPhone 7 Plus&quot;; if ([platform isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;; if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;; if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;; if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;; if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;; if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch 5G&quot;; if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;; if ([platform isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini 1G&quot;; if ([platform isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;; if ([platform isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;; if ([platform isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;; if ([platform isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2G&quot;; if ([platform isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2G&quot;; if ([platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2G&quot;; if ([platform isEqualToString:@&quot;i386&quot;]) return @&quot;iPhone Simulator&quot;; if ([platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;; return platform;&#125; 30.长按复制功能12345678910- (void)viewDidLoad&#123; [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];&#125;- (void)pasteBoard:(UILongPressGestureRecognizer *)longPress &#123; if (longPress.state == UIGestureRecognizerStateBegan) &#123; UIPasteboard *pasteboard = [UIPasteboard generalPasteboard]; pasteboard.string = @&quot;需要复制的文本&quot;; &#125;&#125; 31.判断图片类型12345678910111213141516171819202122232425262728293031323334353637//通过图片Data数据第一个字节 来获取图片扩展名- (NSString *)contentTypeForImageData:(NSData *)data&#123; uint8_t c; [data getBytes:&amp;c length:1]; switch (c) &#123; case 0xFF: return @&quot;jpeg&quot;; case 0x89: return @&quot;png&quot;; case 0x47: return @&quot;gif&quot;; case 0x49: case 0x4D: return @&quot;tiff&quot;; case 0x52: if ([data length] &lt; 12) &#123; return nil; &#125; NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding]; if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123; return @&quot;webp&quot;; &#125; return nil; &#125; return nil;&#125; 32.获取手机和app信息12345678910111213141516171819202122232425262728293031323334353637383940NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; CFShow(infoDictionary); // app名称 NSString *app_Name = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;]; // app版本 NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;]; // app build版本 NSString *app_build = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;]; //手机序列号 NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier]; NSLog(@&quot;手机序列号: %@&quot;,identifierNumber); //手机别名： 用户定义的名称 NSString* userPhoneName = [[UIDevice currentDevice] name]; NSLog(@&quot;手机别名: %@&quot;, userPhoneName); //设备名称 NSString* deviceName = [[UIDevice currentDevice] systemName]; NSLog(@&quot;设备名称: %@&quot;,deviceName ); //手机系统版本 NSString* phoneVersion = [[UIDevice currentDevice] systemVersion]; NSLog(@&quot;手机系统版本: %@&quot;, phoneVersion); //手机型号 NSString* phoneModel = [[UIDevice currentDevice] model]; NSLog(@&quot;手机型号: %@&quot;,phoneModel ); //地方型号 （国际化区域名称） NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel]; NSLog(@&quot;国际化区域名称: %@&quot;,localPhoneModel ); NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary]; // 当前应用名称 NSString *appCurName = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;]; NSLog(@&quot;当前应用名称：%@&quot;,appCurName); // 当前应用软件版本 比如：1.0.1 NSString *appCurVersion = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;]; NSLog(@&quot;当前应用软件版本:%@&quot;,appCurVersion); // 当前应用版本号码 int类型 NSString *appCurVersionNum = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;]; NSLog(@&quot;当前应用版本号码：%@&quot;,appCurVersionNum); 33.获取一个类的所有属性1234567id LenderClass = objc_getClass(&quot;Lender&quot;);unsigned int outCount, i;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);for (i = 0; i &lt; outCount; i++) &#123; objc_property_t property = properties[i]; fprintf(stdout, &quot;%s %s\\n&quot;, property_getName(property), property_getAttributes(property));&#125; 34.image的圆角123456789101112131415161718- (UIImage *)circleImage&#123; // NO代表透明 UIGraphicsBeginImageContextWithOptions(self.size, NO, 1); // 获得上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 添加一个圆 CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); // 方形变圆形 CGContextAddEllipseInRect(ctx, rect); // 裁剪 CGContextClip(ctx); // 将图片画上去 [self drawInRect:rect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 35.image拉伸123456+ (UIImage *)resizableImage:(NSString *)imageName&#123; UIImage *image = [UIImage imageNamed:imageName]; CGFloat imageW = image.size.width; CGFloat imageH = image.size.height; return [image resizableImageWithCapInsets:UIEdgeInsetsMake(imageH * 0.5, imageW * 0.5, imageH * 0.5, imageW * 0.5) resizingMode:UIImageResizingModeStretch]; 36.Json字符转字典12345+ (NSDictionary *)parseJSONStringToNSDictionary:(NSString *)JSONString &#123; NSData *JSONData = [JSONString dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingMutableLeaves error:nil]; return responseJSON;&#125; 37.身份证号验证12345678910- (BOOL)validateIdentityCard &#123; BOOL flag; if (self.length &lt;= 0) &#123; flag = NO; return flag; &#125; NSString *regex2 = @&quot;^(\\\\d&#123;14&#125;|\\\\d&#123;17&#125;)(\\\\d|[xX])$&quot;; NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,regex2]; return [identityCardPredicate evaluateWithObject:self];&#125; 38.获取mac地址12345678910111213141516171819202122232425262728293031323334353637383940414243+ (NSString *)macAddress &#123; int mib[6]; size_t len; char *buf; unsigned char *ptr; struct if_msghdr *ifm; struct sockaddr_dl *sdl; mib[0] = CTL_NET; mib[1] = AF_ROUTE; mib[2] = 0; mib[3] = AF_LINK; mib[4] = NET_RT_IFLIST; if((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123; printf(&quot;Error: if_nametoindex error\\n&quot;); return NULL; &#125; if(sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123; printf(&quot;Error: sysctl, take 1\\n&quot;); return NULL; &#125; if((buf = malloc(len)) == NULL) &#123; printf(&quot;Could not allocate memory. Rrror!\\n&quot;); return NULL; &#125; if(sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123; printf(&quot;Error: sysctl, take 2&quot;); return NULL; &#125; ifm = (struct if_msghdr *)buf; sdl = (struct sockaddr_dl *)(ifm + 1); ptr = (unsigned char *)LLADDR(sdl); NSString *outstring = [NSString stringWithFormat:@&quot;X:X:X:X:X:X&quot;, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)]; free(buf); return outstring;&#125; 39.拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到12345678910111213- (UIViewController *)getVisibleViewControllerFrom:(UIViewController*)vc &#123; if ([vc isKindOfClass:[UINavigationController class]]) &#123; return [self getVisibleViewControllerFrom:[((UINavigationController*) vc) visibleViewController]]; &#125;else if ([vc isKindOfClass:[UITabBarController class]])&#123; return [self getVisibleViewControllerFrom:[((UITabBarController*) vc) selectedViewController]]; &#125; else &#123; if (vc.presentedViewController) &#123; return [self getVisibleViewControllerFrom:vc.presentedViewController]; &#125; else &#123; return vc; &#125; &#125;&#125; 40.runtime动态增加一个属性 以及获取动态增加的属性123// 动态添加属性的本质是: 让对象的某个属性与值产生关联 objc_setAssociatedObject(self, WZBPlaceholderViewKey, placeholderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC); objc_getAssociatedObject(self, WZBPlaceholderViewKey); 41.KVO监听某个对象的属性12345678910// 添加监听者[self addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:nil]; // 当监听的属性值变化的时候会来到这个方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if ([keyPath isEqualToString:@&quot;property&quot;]) &#123; [self textViewTextChange]; &#125; else &#123; &#125;&#125; 42.Reachability判断网络状态12345678910NetworkStatus status = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus]; if (status == NotReachable) &#123; NSLog(@&quot;当前设备无网络&quot;); &#125; if (status == ReachableViaWiFi) &#123; NSLog(@&quot;当前wifi网络&quot;); &#125; if (status == NotReachable) &#123; NSLog(@&quot;当前蜂窝移动网络&quot;); &#125; 43.AFNetworking监听网络状态123456789101112131415161718192021// 监听网络状况 AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager]; [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; switch (status) &#123; case AFNetworkReachabilityStatusUnknown: break; case AFNetworkReachabilityStatusNotReachable: &#123; [SVProgressHUD showInfoWithStatus:@&quot;当前设备无网络&quot;]; &#125; break; case AFNetworkReachabilityStatusReachableViaWiFi: [SVProgressHUD showInfoWithStatus:@&quot;当前Wi-Fi网络&quot;]; break; case AFNetworkReachabilityStatusReachableViaWWAN: [SVProgressHUD showInfoWithStatus:@&quot;当前蜂窝移动网络&quot;]; break; default: break; &#125; &#125;]; [mgr startMonitoring]; 44.取图片某一点的颜色12345678910111213141516171819202122232425262728293031323334353637383940if (point.x &lt; 0 || point.y &lt; 0) return nil; CGImageRef imageRef = self.CGImage; NSUInteger width = CGImageGetWidth(imageRef); NSUInteger height = CGImageGetHeight(imageRef); if (point.x &gt;= width || point.y &gt;= height) return nil; unsigned char *rawData = malloc(height * width * 4); if (!rawData) return nil; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel * width; NSUInteger bitsPerComponent = 8; CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big); if (!context) &#123; free(rawData); return nil; &#125; CGColorSpaceRelease(colorSpace); CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGContextRelease(context); int byteIndex = (bytesPerRow * point.y) + point.x * bytesPerPixel; CGFloat red = (rawData[byteIndex] * 1.0) / 255.0; CGFloat green = (rawData[byteIndex + 1] * 1.0) / 255.0; CGFloat blue = (rawData[byteIndex + 2] * 1.0) / 255.0; CGFloat alpha = (rawData[byteIndex + 3] * 1.0) / 255.0; UIColor *result = nil; result = [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; free(rawData); return result; 45.判断图片是否有透明度12345678 - (BOOL)hasAlphaChannel&#123; CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage); return (alpha == kCGImageAlphaFirst || alpha == kCGImageAlphaLast || alpha == kCGImageAlphaPremultipliedFirst || alpha == kCGImageAlphaPremultipliedLast);&#125; 46.获得灰度图123456789101112131415161718192021+ (UIImage*)covertToGrayImageFromImage:(UIImage*)sourceImage&#123; int width = sourceImage.size.width; int height = sourceImage.size.height; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray(); CGContextRef context = CGBitmapContextCreate (nil,width,height,8,0,colorSpace,kCGImageAlphaNone); CGColorSpaceRelease(colorSpace); if (context == NULL) &#123; return nil; &#125; CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage); CGImageRef contextRef = CGBitmapContextCreateImage(context); UIImage *grayImage = [UIImage imageWithCGImage:contextRef]; CGContextRelease(context); CGImageRelease(contextRef); return grayImage;&#125; 47.根据bundle中的文件名读取图片12345678910111213141516171819202122232425262728293031323334353637 + (UIImage *)imageWithFileName:(NSString *)name &#123; NSString *extension = @&quot;png&quot;; NSArray *components = [name componentsSeparatedByString:@&quot;.&quot;]; if ([components count] &gt;= 2) &#123; NSUInteger lastIndex = components.count - 1; extension = [components objectAtIndex:lastIndex]; name = [name substringToIndex:(name.length-(extension.length+1))]; &#125; // 如果为Retina屏幕且存在对应图片，则返回Retina图片，否则查找普通图片 if ([UIScreen mainScreen].scale == 2.0) &#123; name = [name stringByAppendingString:@&quot;@2x&quot;]; NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension]; if (path != nil) &#123; return [UIImage imageWithContentsOfFile:path]; &#125; &#125; if ([UIScreen mainScreen].scale == 3.0) &#123; name = [name stringByAppendingString:@&quot;@3x&quot;]; NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension]; if (path != nil) &#123; return [UIImage imageWithContentsOfFile:path]; &#125; &#125; NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension]; if (path) &#123; return [UIImage imageWithContentsOfFile:path]; &#125; return nil;&#125; 48.合并两个图片123456789101112131415+ (UIImage*)mergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage &#123; CGImageRef firstImageRef = firstImage.CGImage; CGFloat firstWidth = CGImageGetWidth(firstImageRef); CGFloat firstHeight = CGImageGetHeight(firstImageRef); CGImageRef secondImageRef = secondImage.CGImage; CGFloat secondWidth = CGImageGetWidth(secondImageRef); CGFloat secondHeight = CGImageGetHeight(secondImageRef); CGSize mergedSize = CGSizeMake(MAX(firstWidth, secondWidth), MAX(firstHeight, secondHeight)); UIGraphicsBeginImageContext(mergedSize); [firstImage drawInRect:CGRectMake(0, 0, firstWidth, firstHeight)]; [secondImage drawInRect:CGRectMake(0, 0, secondWidth, secondHeight)]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 49.为imageView添加倒影1234567891011121314151617181920212223CGRect frame = self.frame; frame.origin.y += (frame.size.height + 1); UIImageView *reflectionImageView = [[UIImageView alloc] initWithFrame:frame]; self.clipsToBounds = TRUE; reflectionImageView.contentMode = self.contentMode; [reflectionImageView setImage:self.image]; reflectionImageView.transform = CGAffineTransformMakeScale(1.0, -1.0); CALayer *reflectionLayer = [reflectionImageView layer]; CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.bounds = reflectionLayer.bounds; gradientLayer.position = CGPointMake(reflectionLayer.bounds.size.width / 2, reflectionLayer.bounds.size.height * 0.5); gradientLayer.colors = [NSArray arrayWithObjects: (id)[[UIColor clearColor] CGColor], (id)[[UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.3] CGColor], nil]; gradientLayer.startPoint = CGPointMake(0.5,0.5); gradientLayer.endPoint = CGPointMake(0.5,1.0); reflectionLayer.mask = gradientLayer; [self.superview addSubview:reflectionImageView]; 50.为图片添加水印1234567891011121314- (void) setImage:(UIImage *)image withWaterMark:(UIImage *)mark inRect:(CGRect)rect&#123; if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 4.0) &#123; UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0); &#125; //原图 [image drawInRect:self.bounds]; //水印图 [mark drawInRect:rect]; UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); self.image = newPic;&#125; 51.让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950自定义UILabel// 重写label的textRectForBounds方法- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines &#123; CGRect rect = [super textRectForBounds:bounds limitedToNumberOfLines:numberOfLines]; switch (self.textAlignmentType) &#123; case WZBTextAlignmentTypeLeftTop: &#123; rect.origin = bounds.origin; &#125; break; case WZBTextAlignmentTypeRightTop: &#123; rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, bounds.origin.y); &#125; break; case WZBTextAlignmentTypeLeftBottom: &#123; rect.origin = CGPointMake(bounds.origin.x, CGRectGetMaxY(bounds) - rect.size.height); &#125; break; case WZBTextAlignmentTypeRightBottom: &#123; rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, CGRectGetMaxY(bounds) - rect.size.height); &#125; break; case WZBTextAlignmentTypeTopCenter: &#123; rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - rect.origin.y); &#125; break; case WZBTextAlignmentTypeBottomCenter: &#123; rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - CGRectGetMaxY(bounds) - rect.size.height); &#125; break; case WZBTextAlignmentTypeLeft: &#123; rect.origin = CGPointMake(0, rect.origin.y); &#125; break; case WZBTextAlignmentTypeRight: &#123; rect.origin = CGPointMake(rect.origin.x, 0); &#125; break; case WZBTextAlignmentTypeCenter: &#123; rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, (CGRectGetHeight(bounds) - CGRectGetHeight(rect)) / 2); &#125; break; default: break; &#125; return rect;&#125;- (void)drawTextInRect:(CGRect)rect &#123; CGRect textRect = [self textRectForBounds:rect limitedToNumberOfLines:self.numberOfLines]; [super drawTextInRect:textRect];&#125; 52.移除字符串中的空格和换行123456+ (NSString *)removeSpaceAndNewline:(NSString *)str &#123; NSString *temp = [str stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; temp = [temp stringByReplacingOccurrencesOfString:@&quot;\\r&quot; withString:@&quot;&quot;]; temp = [temp stringByReplacingOccurrencesOfString:@&quot;\\n&quot; withString:@&quot;&quot;]; return temp;&#125; 53.判断字符串中是否有空格12345678910+ (BOOL)isBlank:(NSString *)str &#123; NSRange _range = [str rangeOfString:@&quot; &quot;]; if (_range.location != NSNotFound) &#123; //有空格 return YES; &#125; else &#123; //没有空格 return NO; &#125;&#125; 54.获取视屏第一帧12345678910NSURL *url = [NSURL URLWithString:filepath]; AVURLAsset *asset1 = [[AVURLAsset alloc] initWithURL:url options:nil]; AVAssetImageGenerator *generate1 = [[AVAssetImageGenerator alloc] initWithAsset:asset1]; generate1.appliesPreferredTrackTransform = YES; NSError *err = NULL; CMTime time = CMTimeMake(1, 2); CGImageRef oneRef = [generate1 copyCGImageAtTime:time actualTime:NULL error:&amp;err]; UIImage *one = [[UIImage alloc] initWithCGImage:oneRef]; return one; 55.获取视频的时长1234567+ (NSInteger)getVideoTimeByUrlString:(NSString *)urlString &#123; NSURL *videoUrl = [NSURL URLWithString:urlString]; AVURLAsset *avUrl = [AVURLAsset assetWithURL:videoUrl]; CMTime time = [avUrl duration]; int seconds = ceil(time.value/time.timescale); return seconds;&#125; 56.字符串是否为空123+ (BOOL)isEqualToNil:(NSString *)str &#123; return str.length &lt;= 0 || [str isEqualToString:@&quot;&quot;] || !str;&#125; 57.删除NSUserDefaults所有记录1234567891011121314//方法一 NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier]; [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain]; //方法二 - (void)resetDefaults &#123; NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) &#123; [defs removeObjectForKey:key]; &#125; [defs synchronize]; &#125;// 方法三[[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]]; 58.禁用系统滑动返回功能12345678910111213141516- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated];if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) &#123;self.navigationController.interactivePopGestureRecognizer.delegate = self; &#125;&#125; - (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) &#123;self.navigationController.interactivePopGestureRecognizer.delegate = nil; &#125;&#125;- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer&#123; return NO;&#125; 59.UILabel设置内边距123456子类化UILabel，重写drawTextInRect方法- (void)drawTextInRect:(CGRect)rect &#123; // 边距，上左下右 UIEdgeInsets insets = &#123;0, 5, 0, 5&#125;; [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];&#125; 60.UILabel设置文字描边12345678910111213141516子类化UILabel，重写drawTextInRect方法- (void)drawTextInRect:(CGRect)rect&#123; CGContextRef c = UIGraphicsGetCurrentContext(); // 设置描边宽度 CGContextSetLineWidth(c, 1); CGContextSetLineJoin(c, kCGLineJoinRound); CGContextSetTextDrawingMode(c, kCGTextStroke); // 描边颜色 self.textColor = [UIColor redColor]; [super drawTextInRect:rect]; // 文本颜色 self.textColor = [UIColor yellowColor]; CGContextSetTextDrawingMode(c, kCGTextFill); [super drawTextInRect:rect];&#125; ####### 61 scrollView滚动到最下边12CGPoint bottomOffset = CGPointMake(0, scrollView.contentSize.height - scrollView.bounds.size.height);[scrollView setContentOffset:bottomOffset animated:YES]; ####### 62 摇一摇功能1234567891011121、打开摇一摇功能 [UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;2、让需要摇动的控制器成为第一响应者[self becomeFirstResponder];3、实现以下方法 // 开始摇动- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event// 取消摇动- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event// 摇动结束- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event 63.获取图片大小12CGFloat imageWidth = image.size.width; CGFloat imageHeight = imageWidth * image.scale; ####### 64.修改UISegmentedControl的字体大小1[segment setTitleTextAttributes:@&#123;NSFontAttributeName : [UIFont systemFontOfSize:15.0f]&#125; forState:UIControlStateNormal]; 65.获取一个view所属的控制器12345678910// view分类方法- (UIViewController *)belongViewController &#123; for (UIView *next = [self superview]; next; next = next.superview) &#123; UIResponder* nextResponder = [next nextResponder]; if ([nextResponder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)nextResponder; &#125; &#125; return nil;&#125; 66.在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花1[UIApplication sharedApplication].networkActivityIndicatorVisible = YES; 67.将一个image保存在相册中1234567891011121314UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);或者#import[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123; PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:image]; changeRequest.creationDate = [NSDate date]; &#125; completionHandler:^(BOOL success, NSError *error) &#123; if (success) &#123; NSLog(@&quot;successfully saved&quot;); &#125; else &#123; NSLog(@&quot;error saving to photos: %@&quot;, error); &#125; &#125;]; 68.UITextView中打开或禁用复制，剪切，选择，全选等功能12345678910111213141516171819- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123;// 返回NO为禁用，YES为开启 // 粘贴 if (action == @selector(paste:)) return NO; // 剪切 if (action == @selector(cut:)) return NO; // 复制 if (action == @selector(copy:)) return NO; // 选择 if (action == @selector(select:)) return NO; // 选中全部 if (action == @selector(selectAll:)) return NO; // 删除 if (action == @selector(delete:)) return NO; // 分享 if (action == @selector(share)) return NO; return [super canPerformAction:action withSender:sender];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/xiaoqiang051512/xiaoqiang051512.github.io/tags/iOS/"}]},{"title":"GithubPages+Hexo+Next搭建博客","date":"2017-05-10T03:59:15.000Z","path":"2017/05/10/我的博客的起源/","text":"前言我想成为一个优秀的程序员，然而在技术成长和人生成长的时候必然会有许多感悟，而这些感悟是让人走的更远的利器，而个人博客是记录这些感悟的的一个不错的选择。所以我想用博客来记录我成长的点点滴滴！！！ 搭建博客的准备我选择的是GithubPages + Hexo + Next,这一种简单高效的方式实现。主要记录Mac系统搭建个人博客的详解。 搭建博客工具在Mac系统下搭建的： Xcode因为从事iOS开发的原因，Mac上已经安装了Xocde，然而Xocde集成了Git，所以就直接省略了下载Git的步骤，如果为Mac系统上未安装Xcode可以去 Git官网下载 Node.js上述步骤完成接下来是安装Node.js官网下载程序 Hexo接下来主角登场，安装Hexo 1npm install hexo-cli -g 若出现安装命令不成功，出现如下错误 解决方法：可输入下面的命令和密码继续完成安装 1sudo npm install --unsafe-perm --verbose 博客本地仓库 Github上创建分支按照下面方式在github创建github的仓库 在你的本地创建一个博客文件夹，打开终端进入到你刚刚创建的目录下，在终端进入到该目录，然后执行Hexo命令，初始化本地博客仓库:1hexo init 你的Github用户名.github.io 注意：这里初始化的时候一定要按上述格式创建，不然可能会初始化不成功，在这里踩过坑，所以记忆犹新。 博客初步完成上述步骤顺利完成后，自己的博客框架就已经基本搭建完成了，Hexo安装后默认使用的是landscape主题，终端进入到你博客的博客本地仓库中 1hexo s --debug 博客的的预览地址就是上述图片中的 http://localhost:4000/.在浏览器输入上述地址，会惊喜的见到如下的模样，有木有很惊喜 Hexo的主题在终端进入到博客本地仓库下，执行下面的命令，等待主题的下载完成 1git clone https://github.com/iissnan/hexo-theme-next themes/next Next主题已经下载完成了，接下来是配置主题了，这里需要细心的一步一步的配置。 上面这个这个是Hexo主站的配置文件,可以直接用用系统的文本编辑器进行编辑,注意编辑时需要与前面参数空一格，首先我们需要将博客地址制定到Github里面，如下图： 注意：这里是repository:更改成你github那个仓库的地址 上述图片已经的样式，里面可以配置关于自己的信息以及其他关键信息，接下俩的重点是主题的配置，打开我们先前下载的Next的主题配置文件，如下图 在主题配置文件可以设置各种信息！可以编辑这个文件进行各种设置，配出你喜欢的博客界面 其他如何写博客我博客是准备用Markdown来写，但是如何在Hexo里面如何写呢？这就需要用Hexo-admin这个插件1npm install --save hexo-admin hexo server -d 完成后就可以在浏览器输入：http://localhost:4000/admin进行在写书写博客了 但是需要注意的是这里需要你申请账号和密码，在主站的配置文件加入下面几行代码,自己写上name和password，这个在你登录 http://localhost:4000/admin 需要用到的 Markdown语言标题“# 标题” 表示一级标题“## 标题”表示二级标题以此类推 “###### 标题”表示六级标题 注意：”#”和【标题】之间建议保留一个字符的空格，这是标准的Markdown写法 列表列表有两种表达形式 - 和 1.来表示，例如“- 文本1”“- 文本2”“1. 文本1”“2. 文本2” 链接和图片“[链接显示的文字] (网址)” 这种格式显示的是链接的语法“! [image] (图片Url)”这种格式显示的是图片的语法 引用“&gt;” 表示一级引用“&gt; &gt;”表示二级引用“&gt;&gt;&gt;”表示三级引用 粗体和斜体Markdown的粗体和斜体很简单，粗体用 两个 星号包含一段文字 ，斜体用 * 包含一段文字就好, 代码引用需要引用 “```”包含代码块就好了 如何往Markdown加载本地图片可以通过七牛,进行图片处理得到图片的Url往博客里面插入","tags":[{"name":"其它","slug":"其它","permalink":"https://github.com/xiaoqiang051512/xiaoqiang051512.github.io/tags/其它/"}]},{"title":"Hello World","date":"2017-04-19T06:27:04.000Z","path":"2017/04/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"其它","slug":"其它","permalink":"https://github.com/xiaoqiang051512/xiaoqiang051512.github.io/tags/其它/"}]}]